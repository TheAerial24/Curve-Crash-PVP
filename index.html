<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curve Crash PVP v1.0.1</title>
    <style>
        body {
            background-color: #000;
            color: #fff;
            font-family: 'Consolas', 'Courier New', monospace;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            overflow: hidden;
            font-size: 0.9em;
        }
        
        canvas {
            background-color: #0a0a0a;
            border: 1px solid #333;
            filter: drop-shadow(0 0 10px #555);
            cursor: pointer;
        }
        #ui {
            display: flex;
            justify-content: space-between;
            width: 640px;
            padding: 5px;
            box-sizing: border-box;
        }
        .player-info { 
            flex-basis: 45%; 
            transition: color 0.2s ease;
        }
        #p1-info { color: #00ffff; text-align: left; }
        #p2-info { color: #ff00ff; text-align: right; }
        .score { font-size: 2.0em; font-weight: bold; }
        .boost-meter {
            width: 100%;
            height: 8px;
            background-color: #333;
            border: 1px solid #555;
            margin-top: 3px;
        }
        .boost-bar {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear, background-color 0.2s ease;
        }
        #p1-boost-bar { background-color: #00ffff; }
        #p2-boost-bar { background-color: #ff00ff; }
        
        #message {
            font-size: 1.2em;
            text-align: center;
            line-height: 1.4;
            text-shadow: 0 0 10px #fff;
            display: none;
            padding: 5px 0;
            width: 640px;
        }
        
        #arena-name {
            font-size: 1em;
            color: #888;
            width: 640px;
            text-align: center;
            height: 1.2em;
        }
        #game-mode {
            font-size: 1.2em;
            color: #fff;
            text-shadow: 0 0 5px #ff0;
            margin-bottom: 5px;
            text-align: center;
            width: 640px;
        }
        /* Style for CTF Timer in-game */
        #ctf-timer {
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 8px #f00;
            text-align: center;
            width: 640px;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div id="p1-info" class="player-info">
            <div class="score" id="p1-score">0</div>
            <div>PLAYER 1 (WASD)</div>
            <div class="boost-meter"><div class="boost-bar" id="p1-boost-bar"></div></div>
        </div>
        <div id="p2-info" class="player-info">
            <div class="score" id="p2-score">0</div>
            <div>PLAYER 2 (ARROWS)</div>
            <div class="boost-meter"><div class="boost-bar" id="p2-boost-bar"></div></div>
        </div>
    </div>
    
    <div id="message"></div>
    
    <div id="arena-name"></div>

    <div id="game-mode"></div>
    <div id="ctf-timer" style="display: none;"></div>
    
    <canvas id="gameCanvas" width="640" height="400"></canvas>

    <script>
        // --- 1. SETUP & CONSTANTS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const p1ScoreEl = document.getElementById('p1-score');
        const p2ScoreEl = document.getElementById('p2-score');
        const p1BoostEl = document.getElementById('p1-boost-bar');
        const p2BoostEl = document.getElementById('p2-boost-bar');
        const p1InfoEl = document.getElementById('p1-info');
        const p2InfoEl = document.getElementById('p2-info');
        const messageEl = document.getElementById('message');
        const arenaNameEl = document.getElementById('arena-name');
        const gameModeEl = document.getElementById('game-mode');
        const ctfTimerEl = document.getElementById('ctf-timer');
        
        const FPS = 60;
        const PLAYER_SIZE = 10;
        const PLAYER_SPEED = 2;
        const BOOST_SPEED = 4;
        const BRAKE_SPEED = 1;
        const TURN_SPEED = 0.08;
        const BOOST_DURATION = 1 * FPS;
        const BOOST_COOLDOWN = 4 * FPS;
        const TRAIL_WIDTH = 4;
        const SPAWN_IMMUNITY_TIME = 60;
        
        // --- MODE-SPECIFIC CONSTANTS ---
        const CTF_ROUND_TIME = 120 * FPS;      // 2 minutes
        const CTF_RESPAWN_TIME = 2 * FPS;        // 2 seconds
        const CTF_TRAIL_LIFETIME = 5 * FPS;      // 5 seconds
        const CTF_SCORE_IMMUNITY_TIME = 5 * FPS; // 5 seconds
        
        const DM_TRAIL_LIFETIME = 8 * FPS;       // 8 seconds (default)
        const DM_WIN_SCORE = 10;                 // DM Win Score

        // --- ZONES MODE CONSTANTS ---
        const ZONES_GAME_TIME = 300 * FPS;     // 5 minutes
        const ZONES_INTERVAL = 15 * FPS;       // 15 seconds
        const ZONES_START_RADIUS = 150;
        const ZONES_END_RADIUS = 30;
        const ZONES_RESPAWN_TIME = 3 * FPS;      // 3 seconds
        const ZONES_TRAIL_LIFETIME = 2 * FPS;    // 2 seconds
        // Total zones in a 5 min game (300s / 15s = 20)
        const ZONES_MAX_COUNT = (ZONES_GAME_TIME / ZONES_INTERVAL) - 1; 

        const FLAG_RADIUS = 10;
        const P1_START_X = 80;
        const P2_START_X = 640 - 80;
        
        // --- Flag Spawn Offset (Behind and slightly below player start) ---
        const FLAG_OFFSET_X = 25; 
        const FLAG_OFFSET_Y = 20;   
        
        let TRAIL_LIFETIME = DM_TRAIL_LIFETIME; 

        const colorPalette = [
            '#00ffff', '#ff00ff', '#00ff00', '#ffff00', '#ff8000',
            '#ffffff', '#ff0000', '#0080ff', '#8000ff', '#008000'
        ];
        
        // --- GAME MODE LIST ---
        const MODES = ['CTF MODE', 'DEATHMATCH', 'ZONES']; 
        let p1ModeIndex = 0; 
        let p2ModeIndex = 0; 
        
        let p1ColorIndex = 0;
        let p2ColorIndex = 1;
        let p1Ready = false;
        let p2Ready = false;

        let gameState = 'start'; 
        let trails = [];
        let particles = [];
        let keys = {};
        let player1, player2;
        
        let gameMode = MODES[0];
        let p1Flag = null, p2Flag = null; 
        let ctfRoundTimer = 0;
        let p1RoundScore = 0; 
        let p2RoundScore = 0;

        // --- ZONES GLOBALS ---
        let zone = null;        // Will hold { x, y, radius }
        let zoneTimer = 0;      // Counts down from ZONES_INTERVAL
        let zoneGameTimer = 0;  // Counts down from ZONES_GAME_TIME
        let zoneCount = 0;      // Tracks how many zones have passed
        
        // --- CONSOLIDATED ARENAS ---
        const arenas = [
            { name: "The Classic", mode: 'DEATHMATCH', obstacles: [], wrapWalls: false },
            { name: "The Pillars", mode: 'CTF MODE', obstacles: [ { x: 200, y: 100, width: 40, height: 200 }, { x: 400, y: 100, width: 40, height: 200 } ], wrapWalls: false },
            { 
              name: "The Gauntlet", 
              mode: 'ZONES', 
              obstacles: [
                // The central block
                { x: 270, y: 170, width: 100, height: 60 },
                // Top-left bunker
                { x: 150, y: 50, width: 40, height: 100 },
                // Bottom-right bunker
                { x: 450, y: 250, width: 40, height: 100 }
              ], 
              wrapWalls: false 
            }
        ];
        
        function getArenaByMode(mode) {
            return arenas.find(a => a.mode === mode);
        }

        let currentArena = getArenaByMode('CTF MODE'); 

        // --- 2. INPUT HANDLING ---

        window.addEventListener('keydown', (e) => {
            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space", "a", "d", "w", "s"].includes(e.key)) {
                e.preventDefault();
            }
            if (gameState === 'colorSelect') {
                handleColorKeys(e.key);
            } else if (gameState === 'modeSelect') {
                handleModeKeys(e.key);
            }
            keys[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        canvas.addEventListener('click', () => {
            if (gameState === 'start') {
                gameState = 'modeSelect'; 
                updateModeMessage();
            } else if (gameState === 'gameOver') {
                initGame();
            }
        });

        // --- 3. PLAYER CLASS ---
        class Player {
            constructor(x, y, angle, color, controls, isP1, homeX) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.color = color;
                this.controls = controls;
                this.speed = PLAYER_SPEED;
                this.isBoosting = false;
                this.boostTimer = 0;
                this.boostCooldownTimer = BOOST_COOLDOWN;
                this.isBraking = false;
                this.isDead = false;
                this.score = 0; // Used for DM wins and ZONES deaths
                this.immunityTimer = 0; // Spawn immunity
                this.scoreImmunityTimer = 0; // NEW: CTF score immunity
                this.isP1 = isP1;
                this.carryingFlag = null;
                this.respawnTimer = 0; 
                this.homeX = homeX;
            }

            update() {
                if (this.isDead) {
                    // All modes with respawn timers check here
                    if (gameMode === 'CTF MODE' || gameMode === 'ZONES') {
                        this.respawnTimer--;
                        if (this.respawnTimer <= 0) {
                            this.respawn();
                        }
                    }
                    return;
                }
                
                if (this.immunityTimer > 0) { this.immunityTimer--; }
                if (this.scoreImmunityTimer > 0) { this.scoreImmunityTimer--; } // NEW
                
                if (keys[this.controls.left]) { this.angle -= TURN_SPEED; }
                if (keys[this.controls.right]) { this.angle += TURN_SPEED; }
                
                if (keys[this.controls.up] && this.boostCooldownTimer >= BOOST_COOLDOWN) {
                    this.isBoosting = true;
                    this.boostTimer = BOOST_DURATION;
                    this.boostCooldownTimer = 0;
                }
                this.isBraking = keys[this.controls.down] && !this.isBoosting;
                if (this.isBoosting) {
                    this.boostTimer--;
                    if (this.boostTimer <= 0) { this.isBoosting = false; }
                } else {
                    if (this.boostCooldownTimer < BOOST_COOLDOWN) { this.boostCooldownTimer++; }
                }
                if (this.isBoosting) { this.speed = BOOST_SPEED; }
                else if (this.isBraking) { this.speed = BRAKE_SPEED; }
                else { this.speed = PLAYER_SPEED; }
                
                const moveX = Math.cos(this.angle) * this.speed;
                const moveY = Math.sin(this.angle) * this.speed;
                
                // Trails are back on for all modes
                trails.push(new TrailSegment(this.x, this.y, this.color));

                this.x += moveX;
                this.y += moveY;
                
                this.checkWallCollision();
                this.checkObstacleCollision();
                this.checkTrailCollision();
                
                if (gameMode === 'CTF MODE') {
                    this.checkFlagInteraction();
                }
                
                if (this.carryingFlag) {
                    this.carryingFlag.x = this.x;
                    this.carryingFlag.y = this.y;
                }
            }
            
            checkFlagInteraction() {
                if (!p1Flag || !p2Flag) return; 
                const homeFlag = this.isP1 ? p1Flag : p2Flag;
                const enemyFlag = this.isP1 ? p2Flag : p1Flag;
                
                if (!this.carryingFlag && !enemyFlag.isCarried) {
                    const dist = Math.sqrt(Math.pow(this.x - enemyFlag.x, 2) + Math.pow(this.y - enemyFlag.y, 2));
                    if (dist < PLAYER_SIZE + FLAG_RADIUS) {
                        this.carryingFlag = enemyFlag;
                        enemyFlag.isCarried = true;
                    }
                }
                
                if (this.carryingFlag && this.carryingFlag.isP1 !== this.isP1) {
                    // Check if player is near their HOME flag spawn point (x-position)
                    const homeFlagSpawnX = this.isP1 ? P1_START_X - FLAG_OFFSET_X : P2_START_X + FLAG_OFFSET_X;
                    
                    // NEW: Check for score immunity
                    if (Math.abs(this.x - homeFlagSpawnX) < 30 && this.scoreImmunityTimer <= 0) {
                        this.isP1 ? p1RoundScore++ : p2RoundScore++;
                        
                        this.carryingFlag.isCarried = false;
                        this.carryingFlag = null;
                        this.isP1 ? p2Flag.reset() : p1Flag.reset();
                        
                        showMessage(`${this.isP1 ? 'PLAYER 1' : 'PLAYER 2'} SCORED! (Score: ${this.isP1 ? p1RoundScore : p2RoundScore})`);
                        updateScoreUI();
                        setTimeout(hideMessage, 1000);
                    }
                }
                
                if (homeFlag.isDropped && !this.carryingFlag) {
                    const dist = Math.sqrt(Math.pow(this.x - homeFlag.x, 2) + Math.pow(this.y - homeFlag.y, 2));
                    if (dist < PLAYER_SIZE + FLAG_RADIUS) {
                        homeFlag.reset();
                        showMessage(`${this.isP1 ? 'P1' : 'P2'} RETURNED THEIR FLAG!`);
                        setTimeout(hideMessage, 1000);
                    }
                }
            }

            checkWallCollision() {
                if (this.immunityTimer > 0) return;
                if (currentArena.wrapWalls) {
                    if (this.x < 0) this.x = canvas.width;
                    if (this.x > canvas.width) this.x = 0;
                    if (this.y < 0) this.y = canvas.height;
                    if (this.y > canvas.height) this.y = 0;
                } else {
                    if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                        this.die();
                    }
                }
            }

            checkObstacleCollision() {
                if (this.immunityTimer > 0) return;
                const playerRadius = PLAYER_SIZE / 2;
                for (let obs of currentArena.obstacles) {
                    if (this.x + playerRadius > obs.x &&
                        this.x - playerRadius < obs.x + obs.width &&
                        this.y + playerRadius > obs.y &&
                        this.y - playerRadius < obs.y + obs.height) {
                        this.die();
                        break;
                    }
                }
            }

            checkTrailCollision() {
                if (this.immunityTimer > 0) return;
                
                const playerRadius = PLAYER_SIZE / 2;
                const trailRadius = TRAIL_WIDTH / 2;
                const collisionThreshold = playerRadius + trailRadius;

                for (let segment of trails) {
                    
                    // Original self-collision check for all modes (grace period)
                    if (segment.color === this.color && segment.lifetime > TRAIL_LIFETIME - 15) {
                        continue;
                    }
                    
                    const dx = this.x - segment.x;
                    const dy = this.y - segment.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < collisionThreshold) { 
                        this.die();
                        break;
                    }
                }
            }

            die() {
                if (this.isDead) return;
                this.isDead = true;
                
                if (gameMode === 'CTF MODE') {
                    this.respawnTimer = CTF_RESPAWN_TIME;
                    this.scoreImmunityTimer = CTF_SCORE_IMMUNITY_TIME; // NEW: Set score immunity
                    
                    // --- Clear player's trail on death in CTF ---
                    for (let i = trails.length - 1; i >= 0; i--) {
                        if (trails[i].color === this.color) {
                            trails.splice(i, 1);
                        }
                    }
                } else if (gameMode === 'DEATHMATCH') {
                    // DEATHMATCH: End the round
                    handleDeathmatchRoundEnd(this.isP1 ? player2 : player1); 
                } else if (gameMode === 'ZONES') {
                    this.score++; // Increment death count
                    this.respawnTimer = ZONES_RESPAWN_TIME; // Set respawn timer
                    updateScoreUI(); // Update UI immediately
                }

                for (let i = 0; i < 30; i++) {
                    particles.push(new Particle(this.x, this.y, this.color));
                }
                this.speed = 0;
                
                // NEW: Handle carried flag on death
                if (this.carryingFlag) {
                    if (gameMode === 'CTF MODE') {
                        this.carryingFlag.reset(); // Flag resets to base
                    } else {
                        // This case shouldn't happen, but good to have
                        this.carryingFlag.isCarried = false;
                        this.carryingFlag.isDropped = true; 
                    }
                    this.carryingFlag = null; // Player is no longer carrying
                }
            }
            
            respawn() {
                this.isDead = false;
                this.respawnTimer = 0;
                this.x = this.homeX;
                this.y = canvas.height / 2;
                this.angle = this.isP1 ? 0 : Math.PI;
                this.immunityTimer = SPAWN_IMMUNITY_TIME;
                this.boostCooldownTimer = BOOST_COOLDOWN;
                // Note: scoreImmunityTimer is NOT reset here, it counts down on its own
            }

            draw() {
                // Don't draw player if they are dead (all modes)
                if (this.isDead) return; 
                
                let draw = true;
                if (this.immunityTimer > 0 && Math.floor(this.immunityTimer / 6) % 2 === 0) {
                    draw = false;
                }
                
                if (this.carryingFlag) {
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 20;
                    draw = true;
                }

                if (draw) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(PLAYER_SIZE, 0);
                    ctx.lineTo(-PLAYER_SIZE / 2, -PLAYER_SIZE / 2);
                    ctx.lineTo(-PLAYER_SIZE / 2, PLAYER_SIZE / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }

                ctx.shadowBlur = 0;
                
                if (this.carryingFlag) {
                    this.carryingFlag.drawSymbol(this.x, this.y - 20);
                }
            }

            drawBoostBar(element) {
                let percent = (this.boostCooldownTimer / BOOST_COOLDOWN) * 100;
                if (this.isBoosting) {
                    percent = (this.boostTimer / BOOST_DURATION) * 100;
                }
                element.style.width = `${percent}%`;
            }
        }
        
        // --- 4. FLAG & TRAIL CLASSES ---
        class Flag {
            // Updated constructor to calculate initial position based on player start and offset
            constructor(playerStartX, playerStartY, color, isP1Flag) {
                let initialX, initialY;
                
                // P1 starts facing right (angle 0), so flag is to the left (behind)
                if (isP1Flag) {
                    initialX = playerStartX - FLAG_OFFSET_X; 
                    initialY = playerStartY + FLAG_OFFSET_Y;
                } else {
                    // P2 starts facing left (angle PI), so flag is to the right (behind)
                    initialX = playerStartX + FLAG_OFFSET_X;
                    initialY = playerStartY + FLAG_OFFSET_Y;
                }
                
                this.initialX = initialX;
                this.initialY = initialY;
                this.x = initialX;
                this.y = initialY;
                this.color = color;
                this.isP1 = isP1Flag; 
                this.isCarried = false;
                this.isDropped = false;
            }
            
            reset() {
                this.x = this.initialX;
                this.y = this.initialY;
                this.isCarried = false;
                this.isDropped = false;
            }

            draw() {
                if (this.isCarried) return;
                
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;

                // Draw Flagpole
                ctx.fillRect(this.x - 1, this.y, 2, 20);
                
                // Draw Flag Shape
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                
                const direction = this.isP1 ? 1 : -1; // P1 flag points right, P2 flag points left
                ctx.lineTo(this.x + FLAG_RADIUS * 2 * direction, this.y + FLAG_RADIUS);
                ctx.lineTo(this.x, this.y + FLAG_RADIUS);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }
            
            drawSymbol(x, y) {
                 ctx.save();
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 5;

                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + FLAG_RADIUS, y + FLAG_RADIUS / 2);
                ctx.lineTo(x, y + FLAG_RADIUS / 2);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }
        
        class TrailSegment {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color; 
                this.lifetime = TRAIL_LIFETIME; // This is set by startGame()
            }
            update() { 
                this.lifetime--; 
            }
            draw() {
                const alpha = this.lifetime / TRAIL_LIFETIME;
                ctx.fillStyle = this.color; 
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, TRAIL_WIDTH / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 3 + 1;
                this.lifetime = 60;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.lifetime--;
            }
            draw() {
                const alpha = this.lifetime / 60;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }
        
        // --- 5. GAME MODE SELECTION LOGIC ---

        function handleModeKeys(key) {
            // P1 Mode Selection (A/D)
            if (key === 'a' && !p1Ready) {
                p1ModeIndex = (p1ModeIndex - 1 + MODES.length) % MODES.length;
            }
            if (key === 'd' && !p1Ready) {
                p1ModeIndex = (p1ModeIndex + 1) % MODES.length;
            }
            // P1 Ready (W/S)
            if (key === 'w') { p1Ready = true; }
            if (key === 's') { p1Ready = false; }

            // P2 Mode Selection (Left/Right)
            if (key === 'ArrowLeft' && !p2Ready) {
                p2ModeIndex = (p2ModeIndex - 1 + MODES.length) % MODES.length;
            }
            if (key === 'ArrowRight' && !p2Ready) {
                p2ModeIndex = (p2ModeIndex + 1) % MODES.length;
            }
            // P2 Ready (Up/Down)
            if (key === 'ArrowUp') { p2Ready = true; }
            if (key === 'ArrowDown') { p2Ready = false; }

            updateModeMessage();

            if (p1Ready && p2Ready && p1ModeIndex === p2ModeIndex) {
                gameMode = MODES[p1ModeIndex];
                gameState = 'colorSelect';
                p1Ready = false; 
                p2Ready = false;
                
                currentArena = getArenaByMode(gameMode);
                
                updateReadyMessage(); 
            }
        }
        
        function updateModeMessage() {
            let p1Text = p1Ready ? "P1: READY" : `P1: ${MODES[p1ModeIndex]}`;
            let p2Text = p2Ready ? "P2: READY" : `P2: ${MODES[p2ModeIndex]}`;
            let message = "SELECT GAME MODE\n" + p1Text + " | " + p2Text + "\n(A/D or L/R to Change, W/UP to Ready)";
            
            if (p1Ready && p2Ready && p1ModeIndex !== p2ModeIndex) {
                message += "\nMODE MISMATCH!";
            }
            showMessage(message);
            const tempArena = getArenaByMode(MODES[p1ModeIndex]);
            arenaNameEl.textContent = `Arena: ${tempArena.name}`;
        }


        // --- 6. COLOR & GAME START LOGIC ---
        
        function handleColorKeys(key) {
            // P1 Color Selection
            if (key === 'a' && !p1Ready) {
                p1ColorIndex = (p1ColorIndex - 1 + colorPalette.length) % colorPalette.length;
                if (p1ColorIndex === p2ColorIndex) { p1ColorIndex = (p1ColorIndex - 1 + colorPalette.length) % colorPalette.length; }
            }
            if (key === 'd' && !p1Ready) {
                p1ColorIndex = (p1ColorIndex + 1) % colorPalette.length;
                if (p1ColorIndex === p2ColorIndex) { p1ColorIndex = (p1ColorIndex + 1) % colorPalette.length; }
            }
            if (key === 'w') { p1Ready = true; }
            if (key === 's') { p1Ready = false; }

            // P2 Color Selection
            if (key === 'ArrowLeft' && !p2Ready) {
                p2ColorIndex = (p2ColorIndex - 1 + colorPalette.length) % colorPalette.length;
                if (p2ColorIndex === p1ColorIndex) { p2ColorIndex = (p2ColorIndex - 1 + colorPalette.length) % colorPalette.length; }
            }
            if (key === 'ArrowRight' && !p2Ready) {
                p2ColorIndex = (p2ColorIndex + 1) % colorPalette.length;
                if (p2ColorIndex === p1ColorIndex) { p2ColorIndex = (p2ColorIndex + 1) % colorPalette.length; }
            }
            if (key === 'ArrowUp') { p2Ready = true; }
            if (key === 'ArrowDown') { p2Ready = false; }

            updateColorUI();
            updateReadyMessage();

            if (p1Ready && p2Ready) {
                proceedToStart();
            }
        }

        function updateColorUI() {
            const p1Color = colorPalette[p1ColorIndex];
            const p2Color = colorPalette[p2ColorIndex];
            p1InfoEl.style.color = p1Color;
            p2InfoEl.style.color = p2Color;
            p1BoostEl.style.backgroundColor = p1Color;
            p2BoostEl.style.backgroundColor = p2Color;
        }

        function updateReadyMessage() {
            let p1Text = p1Ready ? "P1: READY" : "P1: <A/D> Select";
            let p2Text = p2Ready ? "P2: READY" : "P2: <L/R> Select";
            showMessage(`${gameMode} - CHOOSE COLOR\n${p1Text} | ${p2Text}\n(W/UP to Ready, S/DOWN to Unready)`);
        }

        function proceedToStart() {
            player1.color = colorPalette[p1ColorIndex];
            player2.color = colorPalette[p2ColorIndex];
            player1.respawn();
            player2.respawn();
            startGame(); 
        }

        function initGame() {
            player1 = new Player(P1_START_X, canvas.height / 2, 0, colorPalette[p1ColorIndex], { up: 'w', down: 's', left: 'a', right: 'd' }, true, P1_START_X);
            player2 = new Player(P2_START_X, canvas.height / 2, Math.PI, colorPalette[p2ColorIndex], { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' }, false, P2_START_X);
            
            player1.score = 0; // Resets DM wins / ZONES deaths
            player2.score = 0; // Resets DM wins / ZONES deaths
            p1RoundScore = 0; // Resets CTF score
            p2RoundScore = 0; // Resets CTF score
            updateScoreUI();
            
            currentArena = getArenaByMode('CTF MODE'); 
            gameMode = MODES[0]; 
            
            gameState = 'start'; 
            p1Ready = false;
            p2Ready = false;
            p1ModeIndex = 0;
            p2ModeIndex = 0;
            showMessage("WELCOME TO CURVE-CRASH\nClick to Select Game Mode"); 
            arenaNameEl.textContent = "";
            ctfTimerEl.style.display = 'none';
        }
        
        function startGame() {
            trails = [];
            particles = [];
            p1Flag = null; 
            p2Flag = null; 
            ctfTimerEl.style.display = 'none';

            currentArena = getArenaByMode(gameMode); 

            if (gameMode === 'CTF MODE') {
                TRAIL_LIFETIME = CTF_TRAIL_LIFETIME; 
                ctfRoundTimer = CTF_ROUND_TIME;
                p1RoundScore = 0;
                p2RoundScore = 0;
                // --- Flag Instantiation (Uses Px_START_X as 'home') ---
                p1Flag = new Flag(P1_START_X, canvas.height / 2, player1.color, true);
                p2Flag = new Flag(P2_START_X, canvas.height / 2, player2.color, false);
                ctfTimerEl.style.display = 'block';
            } else if (gameMode === 'DEATHMATCH') {
                TRAIL_LIFETIME = DM_TRAIL_LIFETIME; 
                // We DON'T reset player1.score or player2.score here, so it persists
                p1RoundScore = 0; // (Not used in DM, but good to reset)
                p2RoundScore = 0;
            } else if (gameMode === 'ZONES') {
                TRAIL_LIFETIME = ZONES_TRAIL_LIFETIME; // Trails are on
                zoneGameTimer = ZONES_GAME_TIME;
                zoneTimer = 0; // Spawn first zone immediately
                zoneCount = 0;
                zone = null;
                ctfTimerEl.style.display = 'block'; // Show game timer
                // Reset death count for the new ZONES match
                player1.score = 0;
                player2.score = 0;
            }
            
            // Only update UI once after all scores are set
            updateScoreUI();
            
            gameModeEl.textContent = gameMode;
            arenaNameEl.textContent = currentArena.name;
            
            player1.respawn();
            player2.respawn();
            
            startCountdown();
        }
        
        // --- DEATHMATCH SPECIFIC LOGIC ---
        function handleDeathmatchRoundEnd(winner) {
            gameState = 'roundOver';
            trails = []; // Clear trails immediately
            
            if (winner) {
                winner.score++; // This is DM wins
                updateScoreUI();

                // NEW: Check for game over
                if (winner.score >= DM_WIN_SCORE) {
                    gameState = 'gameOver';
                    let winnerName = winner.isP1 ? 'PLAYER 1' : 'PLAYER 2';
                    showMessage(`${winnerName} WINS THE MATCH! (${player1.score}-${player2.score})\n(Click to Restart)`);
                    // DO NOT start a new round
                } else {
                    // Game is not over, show round win and start next round
                    showMessage(`${winner.isP1 ? 'PLAYER 1' : 'PLAYER 2'} WINS THE ROUND!`);
                    setTimeout(() => {
                        startGame(); 
                    }, 2000); 
                }
            } else {
                // It's a draw
                showMessage("DRAW! (Double Kill)");
                setTimeout(() => {
                    startGame(); 
                }, 2000); 
            }
        }

        // --- ZONES MODE LOGIC ---

        function spawnNewZone() {
            zoneCount++;
            
            // Calculate new radius (linear interpolation)
            // Lerp: start + (end - start) * t
            let t = Math.min(zoneCount / ZONES_MAX_COUNT, 1.0); // progress from 0.0 to 1.0
            let newRadius = ZONES_START_RADIUS + (ZONES_END_RADIUS - ZONES_START_RADIUS) * t;
            newRadius = Math.max(newRadius, ZONES_END_RADIUS); // Clamp at min

            // Random position, but not too close to the edge
            let padding = newRadius + 20;
            let newX = Math.random() * (canvas.width - padding * 2) + padding;
            let newY = Math.random() * (canvas.height - padding * 2) + padding;

            zone = {
                x: newX,
                y: newY,
                radius: newRadius
            };

            // Player respawn is now handled by their own respawn timer
        }

        function handleZonesLogic() {
            zoneTimer--;

            if (zoneTimer <= 0) {
                
                // --- NEW: Check for players outside the zone ---
                if (zone) {
                    // Check P1
                    if (!player1.isDead && Math.hypot(player1.x - zone.x, player1.y - zone.y) > zone.radius) {
                        player1.die();
                    }
                    // Check P2
                    if (!player2.isDead && Math.hypot(player2.x - zone.x, player2.y - zone.y) > zone.radius) {
                        player2.die();
                    }
                }
                // --- End of new logic ---

                spawnNewZone();
                zoneTimer = ZONES_INTERVAL; // Reset timer
            }
        }

        function drawZone() {
            if (gameMode === 'ZONES' && zone) {
                // Draw the main zone area
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw an outer "next zone" warning ring
                ctx.globalAlpha = 0.5;
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
                ctx.stroke();

                // Draw a shrinking "timer" ring
                let timerRadius = zone.radius * (zoneTimer / ZONES_INTERVAL);
                ctx.globalAlpha = 0.8;
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(zone.x, zone.y, timerRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.globalAlpha = 1.0;
            }
        }

        // --- GAME FLOW & UI ---

        function startCountdown() {
            gameState = 'countdown';
            showMessage(`ARENA: ${currentArena.name}`);
            
            setTimeout(() => { 
                arenaNameEl.textContent = currentArena.name; 
                gameModeEl.textContent = gameMode; 
                hideMessage();
            }, 1500); 
            
            let count = 3;
            setTimeout(() => {
                showMessage(count);
                const timer = setInterval(() => {
                    count--;
                    if (count > 0) {
                        showMessage(count);
                    } else {
                        showMessage('GO!');
                        clearInterval(timer);
                        setTimeout(() => {
                            gameState = 'playing';
                            hideMessage();
                        }, 500);
                    }
                }, 1000);
            }, 1500); 
        }

        function handleGameOverByTimer() {
            gameState = 'gameOver';
            
            let score1 = (gameMode === 'CTF MODE') ? p1RoundScore : player1.score;
            let score2 = (gameMode ==="CTF MODE") ? p2RoundScore : player2.score;

            let message = '';
            if (gameMode === 'ZONES') {
                // ZONES: Lower score (deaths) wins
                if (score1 < score2) {
                    message = `PLAYER 1 WINS! (Deaths: ${score1}-${score2})`;
                } else if (score2 < score1) {
                    message = `PLAYER 2 WINS! (Deaths: ${score1}-${score2})`;
                } else {
                    message = `GAME TIME UP: TIE! (Deaths: ${score1}-${score2})`;
                }
            } else {
                // CTF & DEATHMATCH: Higher score wins
                if (score1 > score2) {
                    message = `PLAYER 1 WINS! (${score1}-${score2})`;
                } else if (score2 > score1) {
                    message = `PLAYER 2 WINS! (${score1}-${score2})`;
                } else {
                    message = 'GAME TIME UP: TIE!';
                }
            }
            
            showMessage(`${message}\n(Click to Restart)`);
            updateScoreUI();
        }
        
        function updateScoreUI() {
            if (gameMode === 'CTF MODE') {
                p1ScoreEl.textContent = p1RoundScore;
                p2ScoreEl.textContent = p2RoundScore;
            } else { // DEATHMATCH and ZONES
                p1ScoreEl.textContent = player1.score;
                p2ScoreEl.textContent = player2.score;
            }
        }

        function showMessage(text) {
            messageEl.innerHTML = text.toString().replace(/\n/g, '<br>');
            messageEl.style.display = 'block';
        }

        function hideMessage() {
            messageEl.style.display = 'none';
        }
        
        function drawArena() {
            ctx.fillStyle = '#888';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10;
            for (let obs of currentArena.obstacles) {
                ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
            }
            ctx.shadowBlur = 0;
        }

        // --- 7. MAIN GAME LOOP ---
        function gameLoop() {
            const opacity = (gameState === 'roundOver') ? 0.3 : 0.8;
            ctx.fillStyle = `rgba(10, 10, 10, ${opacity})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawArena();
            drawZone(); // Draw zone under players/trails
            
            if (gameState === 'playing') {
                player1.update();
                player2.update();

                if (gameMode === 'CTF MODE') {
                    ctfRoundTimer--;
                    let minutes = Math.floor(ctfRoundTimer / FPS / 60);
                    let seconds = Math.floor((ctfRoundTimer / FPS) % 60);
                    ctfTimerEl.textContent = `FLAG TIME: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                    if (ctfRoundTimer <= 0) {
                        handleGameOverByTimer();
                    }
                } else if (gameMode === 'ZONES') {
                    zoneGameTimer--;
                    let minutes = Math.floor(zoneGameTimer / FPS / 60);
                    let seconds = Math.floor((zoneGameTimer / FPS) % 60);
                    ctfTimerEl.textContent = `GAME TIME: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    handleZonesLogic(); // Run zone logic

                    if (zoneGameTimer <= 0) {
                        handleGameOverByTimer();
                    }
                }
            }

            // Update & Draw Trails
            for (let i = trails.length - 1; i >= 0; i--) {
                trails[i].update();
                trails[i].draw();
                if (trails[i].lifetime <= 0) {
                    trails.splice(i, 1);
                }
            }

            // Update & Draw Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].lifetime <= 0) {
                    particles.splice(i, 1);
                }
            }

            // Draw Flags
            if (gameMode === 'CTF MODE' && p1Flag && p2Flag) {
                p1Flag.draw();
                p2Flag.draw();
            }

            // Draw Players
            player1.draw();
            player2.draw();

            // Update UI
            player1.drawBoostBar(p1BoostEl);
            player2.drawBoostBar(p2BoostEl);
        }

        // --- 8. START GAME ---
        initGame();
        setInterval(gameLoop, 1000 / FPS);

    </script>
</body>
</html>

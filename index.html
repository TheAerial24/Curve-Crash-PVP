<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curve-Crash: Echo</title>
    <style>
        body {
            background-color: #000;
            color: #fff;
            font-family: 'Consolas', 'Courier New', monospace;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            overflow: hidden;
        }
        
        canvas {
            background-color: #0a0a0a;
            border: 1px solid #333;
            filter: drop-shadow(0 0 10px #555);
            cursor: pointer;
        }
        #ui {
            display: flex;
            justify-content: space-between;
            width: 800px;
            padding: 10px;
            padding-top: 20px;
            box-sizing: border-box;
        }
        .player-info { 
            flex-basis: 45%; 
            transition: color 0.2s ease;
        }
        #p1-info { color: #00ffff; text-align: left; }
        #p2-info { color: #ff00ff; text-align: right; }
        .score { font-size: 2.5em; font-weight: bold; }
        .boost-meter {
            width: 100%;
            height: 10px;
            background-color: #333;
            border: 1px solid #555;
            margin-top: 5px;
        }
        .boost-bar {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear, background-color 0.2s ease;
        }
        #p1-boost-bar { background-color: #00ffff; }
        #p2-boost-bar { background-color: #ff00ff; }
        #message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5em;
            text-align: center;
            line-height: 1.4;
            text-shadow: 0 0 10px #fff;
            display: none;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div id="p1-info" class="player-info">
            <div class="score" id="p1-score">0</div>
            <div>PLAYER 1 (WASD)</div>
            <div class="boost-meter"><div class="boost-bar" id="p1-boost-bar"></div></div>
        </div>
        <div id="p2-info" class="player-info">
            <div class="score" id="p2-score">0</div>
            <div>PLAYER 2 (ARROWS)</div>
            <div class="boost-meter"><div class="boost-bar" id="p2-boost-bar"></div></div>
        </div>
    </div>
    <canvas id="gameCanvas" width="800" height="500"></canvas>
    <div id="message"></div>

    <script>
        // --- 1. SETUP & CONSTANTS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const p1ScoreEl = document.getElementById('p1-score');
        const p2ScoreEl = document.getElementById('p2-score');
        const p1BoostEl = document.getElementById('p1-boost-bar');
        const p2BoostEl = document.getElementById('p2-boost-bar');
        const messageEl = document.getElementById('message');
        const p1InfoEl = document.getElementById('p1-info');
        const p2InfoEl = document.getElementById('p2-info');

        const PLAYER_SIZE = 10;
        const PLAYER_SPEED = 2;
        const BOOST_SPEED = 4;
        const BRAKE_SPEED = 1;
        const TURN_SPEED = 0.08;
        const BOOST_DURATION = 1 * 60;
        const BOOST_COOLDOWN = 4 * 60;
        const TRAIL_LIFETIME = 8 * 60;
        const TRAIL_WIDTH = 4;
        const WIN_SCORE = 7;
        const SPAWN_IMMUNITY_TIME = 60;

        // --- NEW: Sudden Death ---
        const SUDDEN_DEATH_TIME = 45 * 60; // 45 seconds

        // --- Color Selection ---
        const colorPalette = [
            '#00ffff', '#ff00ff', '#00ff00', '#ffff00', '#ff8000',
            '#ffffff', '#ff0000', '#0080ff', '#8000ff', '#008000'
        ];
        let p1ColorIndex = 0;
        let p2ColorIndex = 1;
        let p1Ready = false;
        let p2Ready = false;

        // --- Game State ---
        let gameState = 'start';
        let trails = [];
        let particles = [];
        let keys = {};
        let player1, player2;
        
        // --- NEW: Sudden Death State ---
        let roundTimer = 0;
        let isSuddenDeath = false;

        // --- 2. INPUT HANDLING ---

        window.addEventListener('keydown', (e) => {
            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space", "a", "d", "w", "s"].includes(e.key)) {
                e.preventDefault();
            }
            if (gameState === 'colorSelect') {
                handleColorKeys(e.key);
            }
            keys[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        canvas.addEventListener('click', () => {
            if (gameState === 'start') {
                startCountdown();
            } else if (gameState === 'gameOver') {
                initGame();
            }
        });

        // --- 3. PLAYER CLASS ---
        class Player {
            constructor(x, y, angle, color, controls) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.color = color;
                this.controls = controls;
                this.speed = PLAYER_SPEED;
                this.isBoosting = false;
                this.boostTimer = 0;
                this.boostCooldownTimer = BOOST_COOLDOWN;
                this.isBraking = false;
                this.isDead = false;
                this.score = 0;
                this.immunityTimer = 0;
            }

            update() {
                if (this.isDead) return;
                if (this.immunityTimer > 0) { this.immunityTimer--; }
                if (keys[this.controls.left]) { this.angle -= TURN_SPEED; }
                if (keys[this.controls.right]) { this.angle += TURN_SPEED; }
                if (keys[this.controls.up] && this.boostCooldownTimer >= BOOST_COOLDOWN) {
                    this.isBoosting = true;
                    this.boostTimer = BOOST_DURATION;
                    this.boostCooldownTimer = 0;
                }
                this.isBraking = keys[this.controls.down] && !this.isBoosting;
                if (this.isBoosting) {
                    this.boostTimer--;
                    if (this.boostTimer <= 0) { this.isBoosting = false; }
                } else {
                    if (this.boostCooldownTimer < BOOST_COOLDOWN) { this.boostCooldownTimer++; }
                }
                if (this.isBoosting) { this.speed = BOOST_SPEED; }
                else if (this.isBraking) { this.speed = BRAKE_SPEED; }
                else { this.speed = PLAYER_SPEED; }
                
                const moveX = Math.cos(this.angle) * this.speed;
                const moveY = Math.sin(this.angle) * this.speed;
                trails.push(new TrailSegment(this.x, this.y, this.color));
                this.x += moveX;
                this.y += moveY;
                this.checkWallCollision();
                this.checkTrailCollision();
            }

            checkWallCollision() {
                if (this.immunityTimer > 0) return;
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.die();
                }
            }

            checkTrailCollision() {
                if (this.immunityTimer > 0) return;
                const playerRadius = PLAYER_SIZE / 2;
                const trailRadius = TRAIL_WIDTH / 2;
                const collisionThreshold = playerRadius + trailRadius;

                for (let segment of trails) {
                    if (segment.color === this.color && segment.lifetime > TRAIL_LIFETIME - 15) {
                        continue;
                    }
                    const dx = this.x - segment.x;
                    const dy = this.y - segment.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < collisionThreshold) { 
                        this.die();
                        break;
                    }
                }
            }

            die() {
                this.isDead = true;
                for (let i = 0; i < 30; i++) {
                    particles.push(new Particle(this.x, this.y, this.color));
                }
                this.speed = 0;
            }

            draw() {
                if (this.isDead) return;
                if (this.immunityTimer > 0 && Math.floor(this.immunityTimer / 6) % 2 === 0) {
                    return;
                }
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(PLAYER_SIZE, 0);
                ctx.lineTo(-PLAYER_SIZE / 2, -PLAYER_SIZE / 2);
                ctx.lineTo(-PLAYER_SIZE / 2, PLAYER_SIZE / 2);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                ctx.shadowBlur = 0;
            }

            drawBoostBar(element) {
                let percent = (this.boostCooldownTimer / BOOST_COOLDOWN) * 100;
                if (this.isBoosting) {
                    percent = (this.boostTimer / BOOST_DURATION) * 100;
                }
                element.style.width = `${percent}%`;
            }
        }

        // --- 4. TRAIL & PARTICLE CLASSES ---
        class TrailSegment {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.lifetime = TRAIL_LIFETIME;
            }
            update() { 
                // --- NEW: Sudden Death stops trails from fading ---
                if (isSuddenDeath) return;
                this.lifetime--; 
            }
            draw() {
                const alpha = this.lifetime / TRAIL_LIFETIME;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, TRAIL_WIDTH / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 3 + 1;
                this.lifetime = 60;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.lifetime--;
            }
            draw() {
                const alpha = this.lifetime / 60;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }


        // --- 5. GAME LOGIC & STATE ---

        function handleColorKeys(key) {
            if (key === 'a' && !p1Ready) {
                p1ColorIndex = (p1ColorIndex - 1 + colorPalette.length) % colorPalette.length;
                if (p1ColorIndex === p2ColorIndex) {
                    p1ColorIndex = (p1ColorIndex - 1 + colorPalette.length) % colorPalette.length;
                }
            }
            if (key === 'd' && !p1Ready) {
                p1ColorIndex = (p1ColorIndex + 1) % colorPalette.length;
                if (p1ColorIndex === p2ColorIndex) {
                    p1ColorIndex = (p1ColorIndex + 1) % colorPalette.length;
                }
            }
            if (key === 'w') { p1Ready = true; }
            if (key === 's') { p1Ready = false; }

            if (key === 'ArrowLeft' && !p2Ready) {
                p2ColorIndex = (p2ColorIndex - 1 + colorPalette.length) % colorPalette.length;
                if (p2ColorIndex === p1ColorIndex) {
                    p2ColorIndex = (p2ColorIndex - 1 + colorPalette.length) % colorPalette.length;
                }
            }
            if (key === 'ArrowRight' && !p2Ready) {
                p2ColorIndex = (p2ColorIndex + 1) % colorPalette.length;
                if (p2ColorIndex === p1ColorIndex) {
                    p2ColorIndex = (p2ColorIndex + 1) % colorPalette.length;
                }
            }
            if (key === 'ArrowUp') { p2Ready = true; }
            if (key === 'ArrowDown') { p2Ready = false; }

            updateColorUI();
            updateReadyMessage();

            if (p1Ready && p2Ready) {
                proceedToStart();
            }
        }

        function updateColorUI() {
            const p1Color = colorPalette[p1ColorIndex];
            const p2Color = colorPalette[p2ColorIndex];
            p1InfoEl.style.color = p1Color;
            p2InfoEl.style.color = p2Color;
            p1BoostEl.style.backgroundColor = p1Color;
            p2BoostEl.style.backgroundColor = p2Color;
        }

        function updateReadyMessage() {
            let p1Text = p1Ready ? "P1: READY" : "P1: <A/D> Select";
            let p2Text = p2Ready ? "P2: READY" : "P2: <L/R> Select";
            showMessage(`CHOOSE COLOR\n${p1Text} | ${p2Text}\n(W/UP to Ready, S/DOWN to Unready)`);
        }

        function proceedToStart() {
            player1.color = colorPalette[p1ColorIndex];
            player2.color = colorPalette[p2ColorIndex];
            gameState = 'start';
            showMessage('Click to Start');
        }

        function initGame() {
            player1 = new Player(100, canvas.height / 2, 0, colorPalette[p1ColorIndex], {
                up: 'w', down: 's', left: 'a', right: 'd'
            });
            player2 = new Player(canvas.width - 100, canvas.height / 2, Math.PI, colorPalette[p2ColorIndex], {
                up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight'
            });
            
            player1.score = 0;
            player2.score = 0;
            updateScoreUI();
            
            gameState = 'colorSelect';
            p1Ready = false;
            p2Ready = false;
            updateColorUI();
            updateReadyMessage();
        }
        
        function resetRound() {
            trails = [];
            particles = [];

            // --- NEW: Reset Sudden Death state ---
            roundTimer = 0;
            isSuddenDeath = false;
            
            player1.x = 100;
            player1.y = canvas.height / 2;
            player1.angle = 0;
            player1.isDead = false;
            player1.boostCooldownTimer = BOOST_COOLDOWN;
            player1.immunityTimer = SPAWN_IMMUNITY_TIME;

            player2.x = canvas.width - 100;
            player2.y = canvas.height / 2;
            player2.angle = Math.PI;
            player2.isDead = false;
            player2.boostCooldownTimer = BOOST_COOLDOWN;
            player2.immunityTimer = SPAWN_IMMUNITY_TIME;
            
            startCountdown();
        }

        function startCountdown() {
            gameState = 'countdown';
            let count = 3;
            showMessage(count);
            const timer = setInterval(() => {
                count--;
                if (count > 0) {
                    showMessage(count);
                } else {
                    showMessage('GO!');
                    clearInterval(timer);
                    setTimeout(() => {
                        gameState = 'playing';
                        hideMessage();
                    }, 500);
                }
            }, 1000);
        }

        function handleRoundOver() {
            gameState = 'roundOver';
            if (player1.isDead && player2.isDead) {
                showMessage('DRAW');
            } else if (player1.isDead) {
                player2.score++;
                showMessage('PLAYER 2 WINS ROUND');
            } else if (player2.isDead) {
                player1.score++;
                showMessage('PLAYER 1 WINS ROUND');
            }
            updateScoreUI();
            if (player1.score >= WIN_SCORE || player2.score >= WIN_SCORE) {
                gameState = 'gameOver';
                let winner = player1.score > player2.score ? 'PLAYER 1' : 'PLAYER 2';
                showMessage(`${winner} WINS!\n(Click to Restart)`);
            } else {
                setTimeout(resetRound, 3000);
            }
        }
        
        function updateScoreUI() {
            p1ScoreEl.textContent = player1.score;
            p2ScoreEl.textContent = p2ScoreEl.score;
        }

        function showMessage(text) {
            messageEl.innerHTML = text.toString().replace(/\n/g, '<br>');
            messageEl.style.display = 'block';
        }

        function hideMessage() {
            messageEl.style.display = 'none';
        }

        // --- 6. MAIN GAME LOOP ---
        function gameLoop() {
            ctx.fillStyle = 'rgba(10, 10, 10, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (gameState === 'playing') {
                player1.update();
                player2.update();

                // --- NEW: Sudden Death Timer ---
                if (!isSuddenDeath) { 
                    roundTimer++;
                    if (roundTimer > SUDDEN_DEATH_TIME) {
                        isSuddenDeath = true;
                        showMessage('SUDDEN DEATH');
                        // Hide message after 2s, but mode stays active
                        setTimeout(() => {
                            if (gameState === 'playing') hideMessage();
                        }, 2000); 
                    }
                }
            }

            if (gameState === 'colorSelect') {
                ctx.save();
                ctx.fillStyle = colorPalette[p1ColorIndex];
                ctx.shadowColor = colorPalette[p1ColorIndex];
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(canvas.width / 4, canvas.height / 2 + 50);
                ctx.lineTo(canvas.width / 4 - 10, canvas.height / 2 + 60);
                ctx.lineTo(canvas.width / 4 - 10, canvas.height / 2 + 40);
                ctx.closePath();
                ctx.fill();
                ctx.restore();

                ctx.save();
                ctx.fillStyle = colorPalette[p2ColorIndex];
                ctx.shadowColor = colorPalette[p2ColorIndex];
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(canvas.width * 0.75, canvas.height / 2 + 50);
                ctx.lineTo(canvas.width * 0.75 + 10, canvas.height / 2 + 60);
                ctx.lineTo(canvas.width * 0.75 + 10, canvas.height / 2 + 40);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            for (let i = trails.length - 1; i >= 0; i--) {
                trails[i].update();
                if (trails[i].lifetime <= 0) { trails.splice(i, 1); }
            }
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].lifetime <= 0) { particles.splice(i, 1); }
            }

            if (gameState === 'playing' && (player1.isDead || player2.isDead)) {
                handleRoundOver();
            }

            for (let segment of trails) { segment.draw(); }
            if (gameState === 'playing') {
                player1.draw();
                player2.draw();
            }
            for (let particle of particles) { particle.draw(); }
            
            player1.drawBoostBar(p1BoostEl);
            player2.drawBoostBar(p2BoostEl);

            requestAnimationFrame(gameLoop);
        }

        // --- 7. START THE GAME ---
        initGame();
        gameLoop();
    </script>
</body>
</html>

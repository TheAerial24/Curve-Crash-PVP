<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curve-Crash: Echo</title>
    <style>
        body {
            background-color: #000;
            color: #fff;
            font-family: 'Consolas', 'Courier New', monospace;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* --- THIS IS THE FIX --- */
            /* We now align to the top, not the center */
            justify-content: flex-start;
            min-height: 100vh;
            overflow: hidden;
        }
        
        canvas {
            background-color: #0a0a0a;
            border: 1px solid #333;
            filter: drop-shadow(0 0 10px #555);
            cursor: pointer;
        }
        #ui {
            display: flex;
            justify-content: space-between;
            width: 800px;
            padding: 10px;
            padding-top: 20px; /* Add some space at the top */
            box-sizing: border-box;
        }
        .player-info { flex-basis: 45%; }
        #p1-info { color: #00ffff; text-align: left; }
        #p2-info { color: #ff00ff; text-align: right; }
        .score { font-size: 2.5em; font-weight: bold; }
        .boost-meter {
            width: 100%;
            height: 10px;
            background-color: #333;
            border: 1px solid #555;
            margin-top: 5px;
        }
        .boost-bar {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear;
        }
        #p1-boost-bar { background-color: #00ffff; }
        #p2-boost-bar { background-color: #ff00ff; }
        #message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            text-align: center;
            text-shadow: 0 0 10px #fff;
            display: none;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="p1-info" class="player-info">
            <div class="score" id="p1-score">0</div>
            <div>PLAYER 1 (WASD)</div>
            <div class="boost-meter"><div class="boost-bar" id="p1-boost-bar"></div></div>
        </div>
        <div id="p2-info" class="player-info">
            <div class="score" id="p2-score">0</div>
            <div>PLAYER 2 (ARROWS)</div>
            <div class="boost-meter"><div class="boost-bar" id="p2-boost-bar"></div></div>
        </div>
    </div>
    <canvas id="gameCanvas" width="800" height="500"></canvas>
    <div id="message"></div>

    <script>
        // --- 1. SETUP & CONSTANTS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const p1ScoreEl = document.getElementById('p1-score');
        const p2ScoreEl = document.getElementById('p2-score');
        const p1BoostEl = document.getElementById('p1-boost-bar');
        const p2BoostEl = document.getElementById('p2-boost-bar');
        const messageEl = document.getElementById('message');

        const PLAYER_SIZE = 10;
        const PLAYER_SPEED = 2;
        const BOOST_SPEED = 4;
        const BRAKE_SPEED = 1;
        const TURN_SPEED = 0.08;
        const BOOST_DURATION = 1 * 60;
        const BOOST_COOLDOWN = 4 * 60;
        const TRAIL_LIFETIME = 8 * 60;
        const TRAIL_WIDTH = 4;
        const WIN_SCORE = 7;

        let gameState = 'start';
        let trails = [];
        let particles = [];
        let keys = {};
        let player1, player2;

        // --- 2. INPUT HANDLING ---

        window.addEventListener('keydown', (e) => {
            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space"].includes(e.key)) {
                e.preventDefault();
            }
            keys[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        canvas.addEventListener('click', () => {
            if (gameState === 'start') {
                startCountdown();
            } else if (gameState === 'gameOver') {
                initGame();
            }
        });

        // --- 3. PLAYER CLASS ---
        class Player {
            constructor(x, y, angle, color, controls) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.color = color;
                this.controls = controls;
                this.speed = PLAYER_SPEED;
                this.isBoosting = false;
                this.boostTimer = 0;
                this.boostCooldownTimer = BOOST_COOLDOWN;
                this.isBraking = false;
                this.isDead = false;
                this.score = 0;
            }

            update() {
                if (this.isDead) return;
                if (keys[this.controls.left]) { this.angle -= TURN_SPEED; }
                if (keys[this.controls.right]) { this.angle += TURN_SPEED; }
                if (keys[this.controls.up] && this.boostCooldownTimer >= BOOST_COOLDOWN) {
                    this.isBoosting = true;
                    this.boostTimer = BOOST_DURATION;
                    this.boostCooldownTimer = 0;
                }
                this.isBraking = keys[this.controls.down] && !this.isBoosting;
                if (this.isBoosting) {
                    this.boostTimer--;
                    if (this.boostTimer <= 0) { this.isBoosting = false; }
                } else {
                    if (this.boostCooldownTimer < BOOST_COOLDOWN) { this.boostCooldownTimer++; }
                }
                if (this.isBoosting) { this.speed = BOOST_SPEED; }
                else if (this.isBraking) { this.speed = BRAKE_SPEED; }
                else { this.speed = PLAYER_SPEED; }
                
                const moveX = Math.cos(this.angle) * this.speed;
                const moveY = Math.sin(this.angle) * this.speed;
                trails.push(new TrailSegment(this.x, this.y, this.color));
                this.x += moveX;
                this.y += moveY;
                this.checkWallCollision();
                this.checkTrailCollision();
            }

            checkWallCollision() {
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.die();
                }
            }

            checkTrailCollision() {
                for (let segment of trails) {
                    if (segment.lifetime > TRAIL_LIFETIME - 15) continue;
                    const dx = this.x - segment.x;
                    const dy = this.y - segment.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < TRAIL_WIDTH / 2) {
                        this.die();
                        break;
                    }
                }
            }

            die() {
                this.isDead = true;
                for (let i = 0; i < 30; i++) {
                    particles.push(new Particle(this.x, this.y, this.color));
                }
                this.speed = 0;
            }

            draw() {
                if (this.isDead) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(PLAYER_SIZE, 0);
                ctx.lineTo(-PLAYER_SIZE / 2, -PLAYER_SIZE / 2);
                ctx.lineTo(-PLAYER_SIZE / 2, PLAYER_SIZE / 2);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                ctx.shadowBlur = 0;
            }

            drawBoostBar(element) {
                let percent = (this.boostCooldownTimer / BOOST_COOLDOWN) * 100;
                if (this.isBoosting) {
                    percent = (this.boostTimer / BOOST_DURATION) * 100;
                }
                element.style.width = `${percent}%`;
            }
        }

        // --- 4. TRAIL & PARTICLE CLASSES ---
        class TrailSegment {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.lifetime = TRAIL_LIFETIME;
            }
            update() { this.lifetime--; }
            draw() {
                const alpha = this.lifetime / TRAIL_LIFETIME;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, TRAIL_WIDTH / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 3 + 1;
                this.lifetime = 60;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.lifetime--;
            }
            draw() {
                const alpha = this.lifetime / 60;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // --- 5. GAME LOGIC & STATE ---
        function initGame() {
            player1 = new Player(100, canvas.height / 2, 0, '#00ffff', {
                up: 'w', down: 's', left: 'a', right: 'd'
            });
            player2 = new Player(canvas.width - 100, canvas.height / 2, Math.PI, '#ff00ff', {
                up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight'
            });
            player1.score = 0;
            player2.score = 0;
            updateScoreUI();
            gameState = 'start';
            showMessage(`Click to Start`);
        }
        
        function resetRound() {
            trails = [];
            particles = [];
            player1.x = 100;
            player1.y = canvas.height / 2;
            player1.angle = 0;
            player1.isDead = false;
            player1.boostCooldownTimer = BOOST_COOLDOWN;
            player2.x = canvas.width - 100;
            player2.y = canvas.height / 2;
            player2.angle = Math.PI;
            player2.isDead = false;
            player2.boostCooldownTimer = BOOST_COOLDOWN;
            startCountdown();
        }

        function startCountdown() {
            gameState = 'countdown';
            let count = 3;
            showMessage(count);
            const timer = setInterval(() => {
                count--;
                if (count > 0) {
                    showMessage(count);
                } else {
                    showMessage('GO!');
                    clearInterval(timer);
                    setTimeout(() => {
                        gameState = 'playing';
                        hideMessage();
                    }, 500);
                }
            }, 1000);
        }

        function handleRoundOver() {
            gameState = 'roundOver';
            if (player1.isDead && player2.isDead) {
                showMessage('DRAW');
            } else if (player1.isDead) {
                player2.score++;
                showMessage('PLAYER 2 WINS ROUND');
            } else if (player2.isDead) {
                player1.score++;
                showMessage('PLAYER 1 WINS ROUND');
            }
            updateScoreUI();
            if (player1.score >= WIN_SCORE || player2.score >= WIN_SCORE) {
                gameState = 'gameOver';
                let winner = player1.score > player2.score ? 'PLAYER 1' : 'PLAYER 2';
                showMessage(`${winner} WINS!\n(Click to Restart)`);
            } else {
                setTimeout(resetRound, 3000);
            }
        }
        
        function updateScoreUI() {
            p1ScoreEl.textContent = player1.score;
            p2ScoreEl.textContent = player2.score;
        }

        function showMessage(text) {
            messageEl.innerHTML = text.toString().replace('\n', '<br>');
            messageEl.style.display = 'block';
        }

        function hideMessage() {
            messageEl.style.display = 'none';
        }

        // --- 6. MAIN GAME LOOP ---
        function gameLoop() {
            ctx.fillStyle = 'rgba(10, 10, 10, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (gameState === 'playing') {
                player1.update();
                player2.update();
            }

            for (let i = trails.length - 1; i >= 0; i--) {
                trails[i].update();
                if (trails[i].lifetime <= 0) { trails.splice(i, 1); }
            }
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].lifetime <= 0) { particles.splice(i, 1); }
            }

            if (gameState === 'playing' && (player1.isDead || player2.isDead)) {
                handleRoundOver();
            }

            for (let segment of trails) { segment.draw(); }
            player1.draw();
            player2.draw();
            for (let particle of particles) { particle.draw(); }
            player1.drawBoostBar(p1BoostEl);
            player2.drawBoostBar(p2BoostEl);

            requestAnimationFrame(gameLoop);
        }

        // --- 7. START THE GAME ---
        initGame();
        gameLoop();
    </script>
</body>
</html>
